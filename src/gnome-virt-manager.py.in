#!/usr/bin/python
# -*- python -*-

import gconf
import gtk
import gobject
import gtk.gdk
import gtk.glade
from time import time
import re
import os
import os.path
import libvirt

appname = "::PACKAGE::"
gconf_dir = "/apps/" + appname

asset_dir = "::ASSETDIR::"

VMLIST_SORT_NAME = 1
VMLIST_SORT_CPU_USAGE = 2
VMLIST_SORT_MEMORY_USAGE = 3

# Hack for dev purposes
if os.path.exists("./" + appname + ".glade"):
    asset_dir = "."

class vmmAbout:
    def __init__(self):
        self.window = gtk.glade.XML(asset_dir + "/" + appname + ".glade", "vmm-about")
        self.window.get_widget("vmm-about").hide()

        self.window.signal_autoconnect({
            "on_vmm_about_delete_event": self.close,
            })

    def show(self):
        dialog = self.window.get_widget("vmm-about")
        dialog.set_version("0.1")
        dialog.show_all()

    def close(self,ignore1=None,ignore2=None):
        self.window.get_widget("vmm-about").hide()
        return 1


class vmmDetails:
    def __init__(self, vmm, stats, conf, vmname):
        self.window = gtk.glade.XML(asset_dir + "/" + appname + ".glade", "vmm-details")
        self.vmm = vmm
        self.stats = stats
        self.conf = conf
        self.vmname = vmname

        topwin = self.window.get_widget("vmm-details")
        topwin.hide()
        topwin.set_title(vmname + " " + topwin.get_title())

        self.window.get_widget("overview-name").set_text(vmname)

        self.window.get_widget("control-run").set_sensitive(False)
        self.window.get_widget("control-run").set_icon_widget(gtk.Image())
        self.window.get_widget("control-run").get_icon_widget().set_from_file(asset_dir + "/pixmaps/icon_run.png")

        self.window.get_widget("control-pause").set_sensitive(False)
        self.window.get_widget("control-pause").set_icon_widget(gtk.Image())
        self.window.get_widget("control-pause").get_icon_widget().set_from_file(asset_dir + "/pixmaps/icon_pause.png")

        self.window.get_widget("control-shutdown").set_sensitive(False)
        self.window.get_widget("control-shutdown").set_icon_widget(gtk.Image())
        #self.window.get_widget("control-shutdown").get_icon_widget().set_from_file(asset_dir + "/pixmaps/icon_run.png")

        self.window.get_widget("launch-term").set_sensitive(False)
        self.window.get_widget("launch-term").set_icon_widget(gtk.Image())
        self.window.get_widget("launch-term").get_icon_widget().set_from_file(asset_dir + "/pixmaps/icon_launch_term.png")

        self.window.get_widget("take-snapshot").set_sensitive(False)
        self.window.get_widget("take-snapshot").set_icon_widget(gtk.Image())
        self.window.get_widget("take-snapshot").get_icon_widget().set_from_file(asset_dir + "/pixmaps/icon_snapshot.png")



        self.window.get_widget("hw-processor").set_icon_widget(gtk.Image())
        self.window.get_widget("hw-processor").get_icon_widget().set_from_file(asset_dir + "/pixmaps/icon_cpu.png")

        self.window.get_widget("hw-memory").set_icon_widget(gtk.Image())
        #self.window.get_widget("hw-memory").get_icon_widget().set_from_file(asset_dir + "/pixmaps/icon_ram.png")

        self.window.get_widget("hw-disk").set_icon_widget(gtk.Image())
        self.window.get_widget("hw-disk").get_icon_widget().set_from_file(asset_dir + "/pixmaps/icon_hdd.png")

        self.window.get_widget("hw-network").set_icon_widget(gtk.Image())
        self.window.get_widget("hw-network").get_icon_widget().set_from_file(asset_dir + "/pixmaps/icon_ethernet.png")

        self.window.get_widget("hw-add").set_icon_widget(gtk.Image())
        self.window.get_widget("hw-add").get_icon_widget().set_from_file(asset_dir + "/pixmaps/icon_addnew.png")



        conf.on_stats_history_length_changed(self.change_graph_ranges)

        self.window.signal_autoconnect({
            "on_close_details_clicked": self.close,
            "on_vmm_details_delete_event": self.close,
            })

        self.stats.connect_to_signal("vm_updated", self.refresh_overview)
        self.refresh_overview(vmname)
        self.change_graph_ranges()

    def show(self):
        dialog = self.window.get_widget("vmm-details")
        dialog.show_all()

    def close(self,ignore1=None,ignore2=None):
        self.window.get_widget("vmm-details").hide()
        return 1

    def change_graph_ranges(self, ignore1=None,ignore2=None,ignore3=None,ignore4=None):
        len = self.conf.get_stats_history_length()
        self.window.get_widget("overview-cpu-usage-graph").set_range(0, len, 0, 100)
        self.window.get_widget("overview-memory-usage-graph").set_range(0, len, 0, 100)
        self.window.get_widget("overview-network-traffic-graph").set_range(0, len, 0, 100)
        

    def refresh_overview(self, vmname):
        if not(vmname == self.vmname):
            return

        self.window.get_widget("overview-status-text").set_text(self.stats.run_status(vmname))
        self.window.get_widget("overview-status-icon").set_from_pixbuf(self.stats.run_status_icon(vmname))
        self.window.get_widget("overview-cpu-usage-graph").set_vector(self.stats.cpu_time_vector(vmname))
        self.window.get_widget("overview-memory-usage-graph").set_vector(self.stats.current_memory_vector(vmname))
        self.window.get_widget("overview-cpu-usage-text").set_text("%2.2f%%" % self.stats.cpu_time_percentage(vmname))
        self.window.get_widget("overview-memory-usage-text").set_text("%2.2f MB of %2.2f MB" % (self.stats.current_memory(vmname)/1024, self.stats.host_memory_size()/1024))

        #self.window.get_widget("overview-cpu-usage-graph").set_curve_type(gtk.CURVE_TYPE_LINEAR)
        self.window.get_widget("overview-memory-usage-graph").set_curve_type(gtk.CURVE_TYPE_LINEAR)


class vmmPreferences:
    def __init__(self, conf):
        self.window = gtk.glade.XML(asset_dir + "/" + appname + ".glade", "vmm-preferences")
        self.conf = conf
        self.window.get_widget("vmm-preferences").hide()

        self.conf.on_stats_update_interval_changed(self.refresh_update_interval)
        self.conf.on_stats_history_length_changed(self.refresh_history_length)

        self.refresh_update_interval()
        self.refresh_history_length()

        self.window.signal_autoconnect({
            "on_stats_update_interval_changed": self.change_update_interval,
            "on_stats_history_length_changed": self.change_history_length,

            "on_close_clicked": self.close,
            "on_vmm_preferences_delete_event": self.close,
            })

    def close(self,ignore1=None,ignore2=None):
        self.window.get_widget("vmm-preferences").hide()
        return 1

    def show(self):
        self.window.get_widget("vmm-preferences").show_all()

    def refresh_update_interval(self, ignore1=None,ignore2=None,ignore3=None,ignore4=None):
        self.window.get_widget("stats-update-interval").set_value(self.conf.get_stats_update_interval())

    def refresh_history_length(self, ignore1=None,ignore2=None,ignore3=None,ignore4=None):
        self.window.get_widget("stats-history-length").set_value(self.conf.get_stats_history_length())

    def change_update_interval(self, src):
        self.conf.set_stats_update_interval(src.get_value_as_int())

    def change_history_length(self, src):
        self.conf.set_stats_history_length(src.get_value_as_int())


class vmmManager:
    def __init__(self):
        self.window = gtk.glade.XML(asset_dir + "/" + appname + ".glade", "vmm-manager")
        self.conf = vmmConfig()
        self.vmm = libvirt.openReadOnly(None)
        #self.vmm = libvirt.open(None)
        print self.vmm.getInfo()

        self.stats = vmmStats(self.vmm, self.conf)
        self.prepare_vmlist()
        
        self.about = None
        self.preferences = None
        self.details = {}

        # Setup update timers
        self.conf.on_stats_update_interval_changed(self.change_timer_interval)

        self.stats.connect_to_signal("vm_added", self.vm_added)
        self.stats.connect_to_signal("vm_removed", self.vm_removed)

        self.conf.on_vmlist_status_visible_changed(self.toggle_status_visible_widget)
        self.conf.on_vmlist_cpu_usage_visible_changed(self.toggle_cpu_usage_visible_widget)
        self.conf.on_vmlist_memory_usage_visible_changed(self.toggle_memory_usage_visible_widget)
        self.conf.on_vmlist_disk_usage_visible_changed(self.toggle_disk_usage_visible_widget)
        self.conf.on_vmlist_network_traffic_visible_changed(self.toggle_network_traffic_visible_widget)

        self.window.get_widget("menu_view_status").set_active(self.conf.is_vmlist_status_visible())
        self.window.get_widget("menu_view_cpu_usage").set_active(self.conf.is_vmlist_cpu_usage_visible())
        self.window.get_widget("menu_view_memory_usage").set_active(self.conf.is_vmlist_memory_usage_visible())
        self.window.get_widget("menu_view_disk_usage").set_active(self.conf.is_vmlist_disk_usage_visible())
        self.window.get_widget("menu_view_network_traffic").set_active(self.conf.is_vmlist_network_traffic_visible())

        self.window.get_widget("menu_file_new").set_sensitive(False)
        self.window.get_widget("vm-new").set_sensitive(False)
        self.window.get_widget("vm-view").set_sensitive(False)
        self.window.get_widget("vm-view").set_active(0)

        self.window.signal_autoconnect({
            "on_menu_view_status_activate" : self.toggle_status_visible_conf,
            "on_menu_view_cpu_usage_activate" : self.toggle_cpu_usage_visible_conf,
            "on_menu_view_memory_usage_activate" : self.toggle_memory_usage_visible_conf,
            "on_menu_view_disk_usage_activate" : self.toggle_disk_usage_visible_conf,
            "on_menu_view_network_traffic_activate" : self.toggle_network_traffic_visible_conf,

            "on_vm_manager_delete_event": self.exit_app,
            "on_menu_file_quit_activate": self.exit_app,
            "on_vmm_close_clicked": self.exit_app,
            "on_vm_details_clicked": self.show_vm_details,
            "on_menu_edit_details_activate": self.show_vm_details,

            "on_menu_edit_preferences_activate": self.show_preferences,
            "on_menu_help_about_activate": self.show_about,
            })

        self.vm_selected(None)
        self.window.get_widget("vm-list").get_selection().connect("changed", self.vm_selected)

        self.stats.tick()
        self.schedule_timer()

        
    def exit_app(self, ignore=None,ignore2=None):
        gtk.main_quit()

    def schedule_timer(self):
        interval = self.conf.get_stats_update_interval() * 1000
        print "Scheduling at " + str(interval)
        self.timer_started = time() * 1000
        self.timer = gobject.timeout_add(interval, self.refresh_stats)


    def vm_added(self, name):
        vmlist = self.window.get_widget("vm-list")
        model = vmlist.get_model()

        dup = 0
        for row in range(model.iter_n_children(None)):
            vm = model.get_value(model.iter_nth_child(None, row), 0)
            if vm == name:
                dup = 1

        if dup != 1:
            print "Add " + name
            model.append([name])


    def vm_removed(self, name):
        vmlist = self.window.get_widget("vm-list")
        model = vmlist.get_model()

        dup = 0
        for row in range(model.iter_n_children(None)):
            vm = model.get_value(model.iter_nth_child(None, row), 0)
            if vm == name:
                model.remove(model.iter_nth_child(None, row))
                print "Remove " + name
                break

    def current_vm(self):
        vmlist = self.window.get_widget("vm-list")
        selection = vmlist.get_selection()
        active = selection.get_selected()
        if active[1] != None:
            return active[0].get_value(active[1], 0)
        return None

    def show_vm_details(self,ignore):
        vmname = self.current_vm()
        if not(self.details.has_key(vmname)):
            self.details[vmname] = vmmDetails(self.vmm, self.stats, self.conf, vmname)

        self.details[vmname].show()

    def change_timer_interval(self,ignore1,ignore2,ignore3,ignore4):
        print "Removing timer"
        gobject.source_remove(self.timer)
        self.refresh_stats()
        self.schedule_timer()

    def vm_selected(self, selection):
        if selection == None or selection.count_selected_rows() == 0:
            self.window.get_widget("vm-delete").set_sensitive(False)
            self.window.get_widget("vm-details").set_sensitive(False)
            self.window.get_widget("vm-open").set_sensitive(False)
            self.window.get_widget("menu_edit_delete").set_sensitive(False)
            self.window.get_widget("menu_edit_details").set_sensitive(False)
        else:
            #self.window.get_widget("vm-delete").set_sensitive(True)
            self.window.get_widget("vm-delete").set_sensitive(False)
            self.window.get_widget("vm-details").set_sensitive(True)
            #self.window.get_widget("vm-open").set_sensitive(True)
            self.window.get_widget("vm-open").set_sensitive(False)
            #self.window.get_widget("menu_edit_delete").set_sensitive(True)
            self.window.get_widget("menu_edit_delete").set_sensitive(False)
            self.window.get_widget("menu_edit_details").set_sensitive(True)

    def show_about(self, ignore=None):
        if self.about == None:
            self.about = vmmAbout()
        self.about.show()
            
    def show_preferences(self, ignore=None):
        if self.preferences == None:
            self.preferences = vmmPreferences(self.conf)
        self.preferences.show()
            
    def refresh_stats(self):
        self.stats.tick()

        vmlist = self.window.get_widget("vm-list")
        model = vmlist.get_model()

        for row in range(model.iter_n_children(None)):
            model.row_changed(str(row), model.iter_nth_child(None, row))

        return 1
    

    def prepare_vmlist(self):
        vmlist = self.window.get_widget("vm-list")

        model = gtk.ListStore(str)
        vmlist.set_model(model)

        nameCol = gtk.TreeViewColumn("Name")
        statusCol = gtk.TreeViewColumn("Status")
        cpuUsageCol = gtk.TreeViewColumn("CPU usage")
        memoryUsageCol = gtk.TreeViewColumn("Memory usage")
        diskUsageCol = gtk.TreeViewColumn("Disk usage")
        networkTrafficCol = gtk.TreeViewColumn("Network traffic")

        name_txt = gtk.CellRendererText()
        nameCol.pack_start(name_txt, True)
        nameCol.add_attribute(name_txt, 'text', 0)
        nameCol.set_sort_column_id(VMLIST_SORT_NAME)

        vmlist.append_column(nameCol)
        vmlist.append_column(statusCol)
        vmlist.append_column(cpuUsageCol)
        vmlist.append_column(memoryUsageCol)
        vmlist.append_column(diskUsageCol)
        vmlist.append_column(networkTrafficCol)

        status_txt = gtk.CellRendererText()
        status_icon = gtk.CellRendererPixbuf()
        statusCol.pack_start(status_icon, False)
        statusCol.pack_start(status_txt, True)
        statusCol.set_cell_data_func(status_txt, self.status_text, None)
        statusCol.set_cell_data_func(status_icon, self.status_icon, None)        
        statusCol.set_visible(self.conf.is_vmlist_status_visible())




        cpuUsage_txt = gtk.CellRendererText()
        cpuUsage_img = gtk.CellRendererProgress()
        cpuUsageCol.pack_start(cpuUsage_txt, True)
        cpuUsageCol.pack_start(cpuUsage_img, False)
        cpuUsageCol.set_cell_data_func(cpuUsage_txt, self.cpu_usage_text, None)
        cpuUsageCol.set_cell_data_func(cpuUsage_img, self.cpu_usage_img, None)
        cpuUsageCol.set_visible(self.conf.is_vmlist_cpu_usage_visible())
        cpuUsageCol.set_sort_column_id(VMLIST_SORT_CPU_USAGE)
        
        memoryUsage_txt = gtk.CellRendererText()
        memoryUsage_img = gtk.CellRendererProgress()
        memoryUsageCol.pack_start(memoryUsage_txt, True)
        memoryUsageCol.pack_start(memoryUsage_img, True)
        memoryUsageCol.set_cell_data_func(memoryUsage_txt, self.memory_usage_text, None)
        memoryUsageCol.set_cell_data_func(memoryUsage_img, self.memory_usage_img, None)
        memoryUsageCol.set_visible(self.conf.is_vmlist_memory_usage_visible())
        memoryUsageCol.set_sort_column_id(VMLIST_SORT_MEMORY_USAGE)
        
        diskUsage_txt = gtk.CellRendererText()
        diskUsageCol.pack_start(diskUsage_txt, True)
        diskUsageCol.set_cell_data_func(diskUsage_txt, self.disk_usage_text, None)
        diskUsageCol.set_visible(self.conf.is_vmlist_disk_usage_visible())
        
        networkTraffic_txt = gtk.CellRendererText()
        networkTrafficCol.pack_start(networkTraffic_txt, True)
        networkTrafficCol.set_cell_data_func(networkTraffic_txt, self.network_usage_text, None)
        networkTrafficCol.set_visible(self.conf.is_vmlist_network_traffic_visible())

        model.set_sort_func(VMLIST_SORT_NAME, self.vmlist_name_sorter)
        model.set_sort_func(VMLIST_SORT_CPU_USAGE, self.vmlist_cpu_usage_sorter) 
        model.set_sort_func(VMLIST_SORT_MEMORY_USAGE, self.vmlist_memory_usage_sorter)
        model.set_sort_column_id(VMLIST_SORT_NAME, gtk.SORT_ASCENDING)

        #vmlist.set_headers_clickable(True)

    # XXX does python have a built-in sort op like perl's <=> / cmp ?
    def sort_op(self, a, b):
        if a > b:
            return 1
        elif a < b:
            return -1
        return 0

    def vmlist_name_sorter(self, model, iter1, iter2):
        print "Sort "+ model.get_value(iter1, 0) + " <=> " + model.get_value(iter2, 0)
        return self.sort_op(model.get_value(iter1, 0), model.get_value(iter2, 0))

    def vmlist_cpu_usage_sorter(self, model, iter1, iter2):
        return self.sort_op(self.stats.cpu_time(model.get_value(iter1, 0)), self.stats.cpu_time(model.get_value(iter2, 0)))

    def vmlist_memory_usage_sorter(self, model, iter1, iter2):
        return self.sort_op(self.stats.current_memory(model.get_value(iter1, 0)), self.stats.current_memory(model.get_value(iter2, 0)))

    def toggle_status_visible_conf(self, menu):
        self.conf.set_vmlist_status_visible(menu.get_active())

    def toggle_status_visible_widget(self, ignore1, ignore2, ignore3, ignore4):
        menu = self.window.get_widget("menu_view_status")
        vmlist = self.window.get_widget("vm-list")
        col = vmlist.get_column(1)
        col.set_visible(self.conf.is_vmlist_status_visible())

    def toggle_cpu_usage_visible_conf(self, menu):
        self.conf.set_vmlist_cpu_usage_visible(menu.get_active())

    def toggle_cpu_usage_visible_widget(self, ignore1, ignore2, ignore3, ignore4):
        menu = self.window.get_widget("menu_view_cpu_usage")
        vmlist = self.window.get_widget("vm-list")
        col = vmlist.get_column(2)
        col.set_visible(self.conf.is_vmlist_cpu_usage_visible())

    def toggle_memory_usage_visible_conf(self, menu):
        self.conf.set_vmlist_memory_usage_visible(menu.get_active())

    def toggle_memory_usage_visible_widget(self, ignore1, ignore2, ignore3, ignore4):
        menu = self.window.get_widget("menu_view_memory_usage")
        vmlist = self.window.get_widget("vm-list")
        col = vmlist.get_column(3)
        col.set_visible(self.conf.is_vmlist_memory_usage_visible())

    def toggle_disk_usage_visible_conf(self, menu):
        self.conf.set_vmlist_disk_usage_visible(menu.get_active())

    def toggle_disk_usage_visible_widget(self, ignore1, ignore2, ignore3, ignore4):
        menu = self.window.get_widget("menu_view_disk_usage")
        vmlist = self.window.get_widget("vm-list")
        col = vmlist.get_column(4)
        col.set_visible(self.conf.is_vmlist_disk_usage_visible())

    def toggle_network_traffic_visible_conf(self, menu):
        self.conf.set_vmlist_network_traffic_visible(menu.get_active())

    def toggle_network_traffic_visible_widget(self, ignore1, ignore2, ignore3, ignore4):
        menu = self.window.get_widget("menu_view_network_traffic")
        vmlist = self.window.get_widget("vm-list")
        col = vmlist.get_column(5)
        col.set_visible(self.conf.is_vmlist_network_traffic_visible())


    def status_text(self, column, cell, model, iter, data):
        name = model.get_value(iter, 0)
        cell.set_property('text', self.stats.run_status(name))

    def status_icon(self, column, cell, model, iter, data):
        name = model.get_value(iter, 0)
        cell.set_property('pixbuf', self.stats.run_status_icon(name))

    def cpu_usage_text(self,  column, cell, model, iter, data):
        name = model.get_value(iter, 0)
        cell.set_property('text', "%2.2f %%" % self.stats.cpu_time_percentage(name))

    def cpu_usage_img(self,  column, cell, model, iter, data):
        name = model.get_value(iter, 0)
        cell.set_property('text', '')
        cell.set_property('value', self.stats.cpu_time_percentage(name))

    def memory_usage_text(self,  column, cell, model, iter, data):
        name = model.get_value(iter, 0)
        current = self.stats.current_memory(name)
        currentPercent = self.stats.current_memory_percentage(name)
        cell.set_property('text', "%s (%2.2f%%)" % (self.pretty_mem(current) , currentPercent))

    def memory_usage_img(self,  column, cell, model, iter, data):
        name = model.get_value(iter, 0)
        currentPercent = self.stats.current_memory_percentage(name)
        cell.set_property('text', '')
        cell.set_property('value', currentPercent)

    # XXX or should we just always display MB ?
    def pretty_mem(self, mem):
        if mem > (1024*1024):
            return "%2.2f GB" % (mem/(1024.0*1024.0))
        else:
            return "%2.2f MB" % (mem/1024.0)

    # XXX implement me
    def disk_usage_text(self,  column, cell, model, iter, data):
        #cell.set_property('text', "600 MB of 1 GB")
        cell.set_property('text', "-")

    # XXX implement me
    def network_usage_text(self,  column, cell, model, iter, data):
        #cell.set_property('text', "100 bytes/sec")
        cell.set_property('text', "-")

class vmmConfig:
    def __init__(self):
        self.conf = gconf.client_get_default()
        self.conf.add_dir (gconf_dir,
                           gconf.CLIENT_PRELOAD_NONE)

    def is_vmlist_status_visible(self):
        return self.conf.get_bool(gconf_dir + "/vmlist-fields/status")

    def is_vmlist_cpu_usage_visible(self):
        return self.conf.get_bool(gconf_dir + "/vmlist-fields/cpu_usage")

    def is_vmlist_memory_usage_visible(self):
        return self.conf.get_bool(gconf_dir + "/vmlist-fields/memory_usage")

    def is_vmlist_disk_usage_visible(self):
        return self.conf.get_bool(gconf_dir + "/vmlist-fields/disk_usage")

    def is_vmlist_network_traffic_visible(self):
        return self.conf.get_bool(gconf_dir + "/vmlist-fields/network_traffic")



    def set_vmlist_status_visible(self, state):
        self.conf.set_bool(gconf_dir + "/vmlist-fields/status", state)
        
    def set_vmlist_cpu_usage_visible(self, state):
        self.conf.set_bool(gconf_dir + "/vmlist-fields/cpu_usage", state)
        
    def set_vmlist_memory_usage_visible(self, state):
        self.conf.set_bool(gconf_dir + "/vmlist-fields/memory_usage", state)
        
    def set_vmlist_disk_usage_visible(self, state):
        self.conf.set_bool(gconf_dir + "/vmlist-fields/disk_usage", state)
        
    def set_vmlist_network_traffic_visible(self, state):
        self.conf.set_bool(gconf_dir + "/vmlist-fields/network_traffic", state)



    def on_vmlist_status_visible_changed(self, callback):
        self.conf.notify_add(gconf_dir + "/vmlist-fields/status", callback)

    def on_vmlist_cpu_usage_visible_changed(self, callback):
        self.conf.notify_add(gconf_dir + "/vmlist-fields/cpu_usage", callback)

    def on_vmlist_memory_usage_visible_changed(self, callback):
        self.conf.notify_add(gconf_dir + "/vmlist-fields/memory_usage", callback)

    def on_vmlist_disk_usage_visible_changed(self, callback):
        self.conf.notify_add(gconf_dir + "/vmlist-fields/disk_usage", callback)

    def on_vmlist_network_traffic_visible_changed(self, callback):
        self.conf.notify_add(gconf_dir + "/vmlist-fields/network_traffic", callback)



    def get_stats_update_interval(self):
        interval = self.conf.get_int(gconf_dir + "/stats/update-interval")
        if interval < 1:
            return 1
        return interval

    def get_stats_history_length(self):
        history = self.conf.get_int(gconf_dir + "/stats/history-length")
        if history < 10:
            return 10
        return history


    def set_stats_update_interval(self, interval):
        self.conf.set_int(gconf_dir + "/stats/update-interval", interval)

    def set_stats_history_length(self, length):
        self.conf.set_int(gconf_dir + "/stats/history-length", length)


    def on_stats_update_interval_changed(self, callback):
        self.conf.notify_add(gconf_dir + "/stats/update-interval", callback)

    def on_stats_history_length_changed(self, callback):
        self.conf.notify_add(gconf_dir + "/stats/history-length", callback)


class vmmStats:
    def __init__(self, vmm, conf):
        self.vmm = vmm
        self.vms = {}
        self.hostinfo = vmm.getInfo()
        self.conf = conf
        self.callbacks = { "vm_added": [], "vm_removed": [], "vm_updated": [] }

        self.status_icons = {
            "blocked": gtk.gdk.pixbuf_new_from_file(asset_dir + "/pixmaps/state_blocked.png"),
            "crashed": gtk.gdk.pixbuf_new_from_file(asset_dir + "/pixmaps/state_crashed.png"),
            "paused": gtk.gdk.pixbuf_new_from_file(asset_dir + "/pixmaps/state_paused.png"),
            "running": gtk.gdk.pixbuf_new_from_file(asset_dir + "/pixmaps/state_running.png"),
            "shutdown": gtk.gdk.pixbuf_new_from_file(asset_dir + "/pixmaps/state_shutdown.png"),
            "shutoff": gtk.gdk.pixbuf_new_from_file(asset_dir + "/pixmaps/state_shutoff.png"),
            "idle": gtk.gdk.pixbuf_new_from_file(asset_dir + "/pixmaps/state_idle.png"),
            }


    def connect_to_signal(self, name, callback):
        if not(self.callbacks.has_key(name)):
            raise "unknown signal " + name + "requested"

        self.callbacks[name].append(callback)

    def disconnect_from_signal(self, name, callback):
        for i in len(self.callbacks[name]):
            if self.callbacks[i] == callback:
                del self.callbacks[i:i]
                

    def notify_vm_added(self, name):
        for cb in self.callbacks["vm_added"]:
            cb(name)

    def notify_vm_removed(self, name):
        for cb in self.callbacks["vm_removed"]:
            cb(name)

    def notify_vm_updated(self, name):
        for cb in self.callbacks["vm_updated"]:
            cb(name)

    def tick(self):
        print "Tick"
        doms = self.vmm.listDomainsID()
        newVms = {}
        if doms != None:
            for id in self.vmm.listDomainsID():
                vm = self.vmm.lookupByID(id)
                newVms[vm.name()] = vm

        for name in self.vms.keys():
            if not(newVms.has_key(name)):
                del self.vms[name]
                self.notify_vm_removed(name)

        for name in newVms.keys():
            if not(self.vms.has_key(name)):
                self.vms[name] = { "handle": newVms[name],
                                   "stats": [] }
                self.notify_vm_added(name)

        now = time()

        totalCpuTime = 0
        for name in self.vms.keys():
            info = self.vms[name]["handle"].info()

            if (len(self.vms[name]["stats"])+1) > self.conf.get_stats_history_length():
                end = len(self.vms[name]["stats"])
                del self.vms[name]["stats"][end-1:end]

            prevCpuTime = 0
            prevTimestamp = 0
            if len(self.vms[name]["stats"]) > 0:
                prevTimestamp = self.vms[name]["stats"][0]["timestamp"]
                prevCpuTime = self.vms[name]["stats"][0]["cpuTimeAbs"]

            pcentCpuTime = (info[4]-prevCpuTime) * 100 / ((now - prevTimestamp)*1000*1000*1000)
            pcentCpuTime = pcentCpuTime / self.host_active_processor_count()

            pcentCurrMem = info[2] * 100 / self.host_memory_size()
            pcentMaxMem = info[1] * 100 / self.host_memory_size()
            
            newStats = { "timestamp": now,
                          "status": info[0],
                          "cpuTime": (info[4]-prevCpuTime),
                          "cpuTimeAbs": info[4],
                          "cpuTimePercent": pcentCpuTime,
                          "currMem": info[2],
                          "currMemPercent": pcentCurrMem,
                          "maxMem": info[1],
                          "maxMemPercent": pcentMaxMem,
                          }
            totalCpuTime = totalCpuTime + newStats["cpuTime"]
            self.vms[name]["stats"].insert(0, newStats)

            self.notify_vm_updated(name)

    def host_memory_size(self):
        return self.hostinfo[1]*1024

    def host_active_processor_count(self):
        return self.hostinfo[2]

    def host_maximum_processor_count(self):
        return self.hostinfo[4] * self.hostinfo[5] * self.hostinfo[6] * self.hostinfo[7]

    def current_memory(self, name):
        return self.vms[name]["stats"][0]["currMem"]
    
    def current_memory_percentage(self, name):
        return self.vms[name]["stats"][0]["currMemPercent"]
    
    def maximum_memory(self, name):
        return self.vms[name]["stats"][0]["maxMem"]

    def maximum_memory_percentage(self, name):
        return self.vms[name]["stats"][0]["maxMemPercent"]

    def cpu_time(self, name):
        return self.vms[name]["stats"][0]["cpuTime"]
    
    def cpu_time_percentage(self, name):
        return self.vms[name]["stats"][0]["cpuTimePercent"]

    def cpu_time_vector(self, name):
        vector = []
        stats = self.vms[name]["stats"]
        print "Len " + str(len(stats))
        for i in range(self.conf.get_stats_history_length()):
            if i < len(stats):
                vector.append(stats[i]["cpuTimePercent"])
            else:
                vector.append(0)
        return vector
    
    def current_memory_vector(self, name):
        vector = []
        stats = self.vms[name]["stats"]
        for i in range(len(stats)):
            vector.append(stats[i]["currMemPercent"])
        return vector
    
    
    def run_status(self, name):
        status = self.vms[name]["stats"][0]["status"]
        if status == libvirt.VIR_DOMAIN_NOSTATE:
            return "Idle"
        elif status == libvirt.VIR_DOMAIN_RUNNING:
            return "Running"
        elif status == libvirt.VIR_DOMAIN_BLOCKED:
            return "Blocked"
        elif status == libvirt.VIR_DOMAIN_PAUSED:
            return "Paused"
        elif status == libvirt.VIR_DOMAIN_SHUTDOWN:
            return "Shutdown"
        elif status == libvirt.VIR_DOMAIN_SHUTOFF:
            return "Shutoff"
        elif status == libvirt.VIR_DOMAIN_CRASHED:
            return "Crashed"
        else:
            raise "Unknown status code"

    def run_status_icon(self, name):
        status = self.run_status(name)
        return self.status_icons[status.lower()]

        
# Run me!
def main():
    window = vmmManager()
    gtk.main()

if __name__ == "__main__":
    main()
