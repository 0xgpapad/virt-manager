#!/usr/bin/python
# -*- python -*-

import gconf
import gtk
import gobject
import gtk.gdk
import gtk.glade
from time import time
import re
import os
import os.path
import libvirt

import matplotlib
matplotlib.use('GTK')
 
from matplotlib.figure import Figure
from matplotlib.axes import Subplot
from matplotlib.backends.backend_gtk import FigureCanvasGTK, NavigationToolbar
 
from matplotlib.numerix import arange, sin, pi


appname = "::PACKAGE::"
gconf_dir = "/apps/" + appname

asset_dir = "::ASSETDIR::"

VMLIST_SORT_NAME = 1
VMLIST_SORT_CPU_USAGE = 2
VMLIST_SORT_MEMORY_USAGE = 3
VMLIST_SORT_DISK_USAGE = 4
VMLIST_SORT_NETWORK_USAGE = 5

# Hack for dev purposes
if os.path.exists("./" + appname + ".glade"):
    asset_dir = "."

class vmmAbout:
    def __init__(self):
        self.window = gtk.glade.XML(asset_dir + "/" + appname + ".glade", "vmm-about")
        self.window.get_widget("vmm-about").hide()

        self.window.signal_autoconnect({
            "on_vmm_about_delete_event": self.close,
            })

    def show(self):
        dialog = self.window.get_widget("vmm-about")
        dialog.set_version("0.1")
        dialog.show_all()
        dialog.present()

    def close(self,ignore1=None,ignore2=None):
        self.window.get_widget("vmm-about").hide()
        return 1

class vmmConsole:
    def __init__(self, engine, vmname):
        self.window = gtk.glade.XML(asset_dir + "/" + appname + ".glade", "vmm-console")
        self.engine = engine
        self.vmname = vmname
        self.lastStatus = None

        topwin = self.window.get_widget("vmm-console")
        topwin.hide()
        topwin.set_title(vmname + " " + topwin.get_title())

        self.window.get_widget("control-run").set_icon_widget(gtk.Image())
        self.window.get_widget("control-run").get_icon_widget().set_from_file(asset_dir + "/pixmaps/icon_run.png")

        self.window.get_widget("control-pause").set_icon_widget(gtk.Image())
        self.window.get_widget("control-pause").get_icon_widget().set_from_file(asset_dir + "/pixmaps/icon_pause.png")

        self.window.get_widget("control-shutdown").set_icon_widget(gtk.Image())
        #self.window.get_widget("control-shutdown").get_icon_widget().set_from_file(asset_dir + "/pixmaps/icon_run.png")

        self.window.get_widget("control-terminal").set_icon_widget(gtk.Image())
        self.window.get_widget("control-terminal").get_icon_widget().set_from_file(asset_dir + "/pixmaps/icon_launch_term.png")

        self.window.get_widget("control-snapshot").set_icon_widget(gtk.Image())
        self.window.get_widget("control-snapshot").get_icon_widget().set_from_file(asset_dir + "/pixmaps/icon_snapshot.png")


        self.window.signal_autoconnect({
            "on_vmm_console_delete_event": self.close,

            "on_control_run_clicked": self.control_vm_run,
            "on_control_shutdown_clicked": self.control_vm_shutdown,
            "on_control_pause_toggled": self.control_vm_pause,

            "on_control_terminal_clicked": self.control_vm_terminal,
            "on_control_snapshot_clicked": self.control_vm_snapshot,
            "on_control_details_clicked": self.control_vm_details,
            })

        self.engine.connect_to_signal("vm_updated", self.refresh_status)
        self.refresh_status(vmname)

    def show(self):
        dialog = self.window.get_widget("vmm-console")
        dialog.show_all()
        dialog.present()

    def close(self,ignore1=None,ignore2=None):
        self.window.get_widget("vmm-console").hide()
        return 1

    def control_vm_run(self, src):
        return 0

    def control_vm_shutdown(self, src):
        if not(self.engine.get_stats().run_status(self.vmname) in [ "shutdown", "shutoff" ]):
            self.vmm.shutdown()
        else:
            print "Shutdown requested, but machine is already shutting down / shutoff"

    def control_vm_pause(self, src):
        if self.engine.get_stats().run_status(self.vmname) in [ "shutdown", "shutoff" ]:
            print "Pause/resume requested, but machine is shutdown / shutoff"
        else:
            if self.engine.get_stats().run_status(self.vmname) in [ "paused" ]:
                if not src.get_active():
                    self.vmm.resume()
                else:
                    print "Pause requested, but machine is already paused"
            else:
                if src.get_active():
                    self.vmm.suspend()
                else:
                    print "Resume requested, but machine is already running"


    def control_vm_terminal(self, src):
        return 0

    def control_vm_snapshot(self, src):
        return 0

    def control_vm_details(self, src):
        self.engine.show_details(self.vmname)

    def refresh_status(self, vmname):
        if not(vmname == self.vmname):
            return

        status = self.engine.get_stats().run_status(vmname)

        if self.lastStatus == status:
            return

        if status == "shutoff":
            self.window.get_widget("control-run").set_sensitive(True)
        else:
            self.window.get_widget("control-run").set_sensitive(False)

        if status in [ "shutoff", "shutdown" ]:
            self.window.get_widget("control-pause").set_sensitive(False)
            self.window.get_widget("control-shutdown").set_sensitive(False)
            self.window.get_widget("control-terminal").set_sensitive(False)
            self.window.get_widget("control-snapshot").set_sensitive(False)            
        else:
            self.window.get_widget("control-pause").set_sensitive(True)
            self.window.get_widget("control-shutdown").set_sensitive(True)
            self.window.get_widget("control-terminal").set_sensitive(True)
            self.window.get_widget("control-snapshot").set_sensitive(True)            
            if status == "paused":
                self.window.get_widget("control-pause").set_active(True)
            else:
                self.window.get_widget("control-pause").set_active(False)

        self.lastStatus = status


class vmmDetails:
    def __init__(self, engine, vmname):
        self.window = gtk.glade.XML(asset_dir + "/" + appname + ".glade", "vmm-details")
        self.engine = engine
        self.vmname = vmname
        self.lastStatus = None

        topwin = self.window.get_widget("vmm-details")
        topwin.hide()
        topwin.set_title(vmname + " " + topwin.get_title())

        self.window.get_widget("overview-name").set_text(vmname)

        self.window.get_widget("control-run").set_icon_widget(gtk.Image())
        self.window.get_widget("control-run").get_icon_widget().set_from_file(asset_dir + "/pixmaps/icon_run.png")

        self.window.get_widget("control-pause").set_icon_widget(gtk.Image())
        self.window.get_widget("control-pause").get_icon_widget().set_from_file(asset_dir + "/pixmaps/icon_pause.png")

        self.window.get_widget("control-shutdown").set_icon_widget(gtk.Image())
        #self.window.get_widget("control-shutdown").get_icon_widget().set_from_file(asset_dir + "/pixmaps/icon_run.png")

        self.window.get_widget("control-terminal").set_icon_widget(gtk.Image())
        self.window.get_widget("control-terminal").get_icon_widget().set_from_file(asset_dir + "/pixmaps/icon_launch_term.png")

        self.window.get_widget("control-snapshot").set_icon_widget(gtk.Image())
        self.window.get_widget("control-snapshot").get_icon_widget().set_from_file(asset_dir + "/pixmaps/icon_snapshot.png")

        self.window.get_widget("hw-panel").set_show_tabs(False)

        hwListModel = gtk.ListStore(int, str, gtk.gdk.Pixbuf)
        self.window.get_widget("hw-list").set_model(hwListModel)

        hwListModel.append([0, "Processor", gtk.gdk.pixbuf_new_from_file(asset_dir + "/pixmaps/icon_cpu.png")])
        #hwListModel.append([1, "Memory", gtk.gdk.pixbuf_new_from_file(asset_dir + "/pixmaps/icon_ram.png")])
        hwListModel.append([1, "Memory", gtk.gdk.pixbuf_new_from_file(asset_dir + "/pixmaps/icon_cpu.png")])
        hwListModel.append([2, "Disk", gtk.gdk.pixbuf_new_from_file(asset_dir + "/pixmaps/icon_hdd.png")])
        hwListModel.append([3, "Network", gtk.gdk.pixbuf_new_from_file(asset_dir + "/pixmaps/icon_ethernet.png")])
        hwListModel.append([4, "Add hardware", gtk.gdk.pixbuf_new_from_file(asset_dir + "/pixmaps/icon_addnew.png")])

        self.window.get_widget("hw-list").get_selection().connect("changed", self.hw_selected)


        hwCol = gtk.TreeViewColumn("Hardware")
        hw_txt = gtk.CellRendererText()
        hw_img = gtk.CellRendererPixbuf()
        hwCol.pack_start(hw_txt, True)
        hwCol.pack_start(hw_img, False)
        hwCol.add_attribute(hw_txt, 'text', 1)
        hwCol.add_attribute(hw_img, 'pixbuf', 2)
        
        self.window.get_widget("hw-list").append_column(hwCol)
        

        self.cpu_usage_figure = Figure()
        self.cpu_usage_graph = self.cpu_usage_figure.add_subplot(111)
        self.cpu_usage_graph.set_autoscale_on(False)
        self.cpu_usage_line = None
        self.cpu_usage_canvas = FigureCanvasGTK(self.cpu_usage_figure)
        self.cpu_usage_canvas.show()
        self.window.get_widget("graph-table").attach(self.cpu_usage_canvas, 1, 2, 0, 1)

        self.memory_usage_figure = Figure()
        self.memory_usage_graph = self.memory_usage_figure.add_subplot(111)
        self.memory_usage_graph.set_autoscale_on(False)
        self.memory_usage_line = None
        self.memory_usage_canvas = FigureCanvasGTK(self.memory_usage_figure)
        self.memory_usage_canvas.show()
        self.window.get_widget("graph-table").attach(self.memory_usage_canvas, 1, 2, 1, 2)

        self.network_traffic_figure = Figure()
        self.network_traffic_graph = self.network_traffic_figure.add_subplot(111)
        self.network_traffic_graph.set_autoscale_on(False)
        self.network_traffic_line = None
        self.network_traffic_canvas = FigureCanvasGTK(self.network_traffic_figure)
        self.network_traffic_canvas.show()
        self.window.get_widget("graph-table").attach(self.network_traffic_canvas, 1, 2, 3, 4)

        self.engine.get_config().on_stats_history_length_changed(self.change_graph_ranges)

        self.window.signal_autoconnect({
            "on_close_details_clicked": self.close,
            "on_vmm_details_delete_event": self.close,

            "on_control_run_clicked": self.control_vm_run,
            "on_control_shutdown_clicked": self.control_vm_shutdown,
            "on_control_pause_toggled": self.control_vm_pause,

            "on_control_terminal_clicked": self.control_vm_terminal,
            "on_control_snapshot_clicked": self.control_vm_snapshot,
            })

        self.engine.connect_to_signal("vm_updated", self.refresh_overview)
        self.change_graph_ranges()
        self.refresh_overview(vmname)
        self.hw_selected()

    def show(self):
        dialog = self.window.get_widget("vmm-details")
        dialog.show_all()
        dialog.present()

    def close(self,ignore1=None,ignore2=None):
        self.window.get_widget("vmm-details").hide()
        return 1

    def hw_selected(self, src=None):
        vmlist = self.window.get_widget("hw-list")
        selection = vmlist.get_selection()
        active = selection.get_selected()
        if active[1] != None:
            print "Activate " + str(active[0].get_value(active[1], 0))
            self.window.get_widget("hw-panel").set_sensitive(True)
            self.window.get_widget("hw-panel").set_current_page(active[0].get_value(active[1], 0))
        else:
            print "Dactive" + str(active)
            self.window.get_widget("hw-panel").set_sensitive(False)

    def control_vm_run(self, src):
        return 0

    def control_vm_shutdown(self, src):
        if not(self.engine.get_stats().run_status(self.vmname) in [ "shutdown", "shutoff" ]):
            self.vmm.shutdown()
        else:
            print "Shutdown requested, but machine is already shutting down / shutoff"

    def control_vm_pause(self, src):
        if self.engine.get_stats().run_status(self.vmname) in [ "shutdown", "shutoff" ]:
            print "Pause/resume requested, but machine is shutdown / shutoff"
        else:
            if self.engine.get_stats().run_status(self.vmname) in [ "paused" ]:
                if not src.get_active():
                    self.vmm.resume()
                else:
                    print "Pause requested, but machine is already paused"
            else:
                if src.get_active():
                    self.vmm.suspend()
                else:
                    print "Resume requested, but machine is already running"


    def control_vm_terminal(self, src):
        return 0

    def control_vm_snapshot(self, src):
        return 0

    def change_graph_ranges(self, ignore1=None,ignore2=None,ignore3=None,ignore4=None):
        self.cpu_usage_graph.clear()
        #self.cpu_usage_graph.set_xlabel('History')
        #self.cpu_usage_graph.set_ylabel('% utilization')
        self.cpu_usage_graph.grid(True)
        self.cpu_usage_line = None

        self.memory_usage_graph.clear()
        #self.memory_usage_graph.set_xlabel('History')
        #self.memory_usage_graph.set_ylabel('% utilization')
        self.memory_usage_graph.grid(True)
        self.memory_usage_line = None

        self.network_traffic_graph.clear()
        #self.network_traffic_graph.set_xlabel('History')
        #self.network_traffic_graph.set_ylabel('% utilization')
        self.network_traffic_graph.grid(True)
        self.network_traffic_line = None

    def update_widget_states(self, status):
        if self.lastStatus == status:
            return

        if status == "shutoff":
            self.window.get_widget("control-run").set_sensitive(True)
        else:
            self.window.get_widget("control-run").set_sensitive(False)

        if status in [ "shutoff", "shutdown" ]:
            self.window.get_widget("control-pause").set_sensitive(False)
            self.window.get_widget("control-shutdown").set_sensitive(False)
            self.window.get_widget("control-terminal").set_sensitive(False)
            self.window.get_widget("control-snapshot").set_sensitive(False)            
        else:
            self.window.get_widget("control-pause").set_sensitive(True)
            self.window.get_widget("control-shutdown").set_sensitive(True)
            self.window.get_widget("control-terminal").set_sensitive(True)
            self.window.get_widget("control-snapshot").set_sensitive(True)            
            if status == "paused":
                self.window.get_widget("control-pause").set_active(True)
            else:
                self.window.get_widget("control-pause").set_active(False)

        self.lastStatus = status

    def refresh_overview(self, vmname):
        if not(vmname == self.vmname):
            return

        status = self.engine.get_stats().run_status(vmname)
        self.update_widget_states(status)

        self.window.get_widget("overview-status-text").set_text(status)
        self.window.get_widget("overview-status-icon").set_from_pixbuf(self.engine.get_stats().run_status_icon(vmname))
        self.window.get_widget("overview-cpu-usage-text").set_text("%d %%" % self.engine.get_stats().cpu_time_percentage(vmname))
        self.window.get_widget("overview-memory-usage-text").set_text("%d MB of %d MB" % (self.engine.get_stats().current_memory(vmname)/1024, self.engine.get_stats().host_memory_size()/1024))

        history_len = self.engine.get_config().get_stats_history_length()
        cpu_vector = self.engine.get_stats().cpu_time_vector(vmname)
        cpu_vector.reverse()
        if self.cpu_usage_line == None:
            self.cpu_usage_line = self.cpu_usage_graph.plot(cpu_vector)
            self.cpu_usage_graph.set_xlim(0, history_len)
            self.cpu_usage_graph.set_ylim(0, 100)
        else:
            self.cpu_usage_line[0].set_ydata(cpu_vector)
            self.cpu_usage_graph.set_xlim(0, history_len)
            self.cpu_usage_graph.set_ylim(0, 100)
        self.cpu_usage_graph.set_yticklabels(["0","","","","","100"])
        self.cpu_usage_graph.set_xticklabels([])
        self.cpu_usage_canvas.draw()

        history_len = self.engine.get_config().get_stats_history_length()
        memory_vector = self.engine.get_stats().current_memory_vector(vmname)
        memory_vector.reverse()
        if self.memory_usage_line == None:
            self.memory_usage_line = self.memory_usage_graph.plot(memory_vector)
            self.memory_usage_graph.set_xlim(0, history_len)
            self.memory_usage_graph.set_ylim(0, 100)
        else:
            self.memory_usage_line[0].set_ydata(memory_vector)
            self.memory_usage_graph.set_xlim(0, history_len)
            self.memory_usage_graph.set_ylim(0, 100)
        self.memory_usage_graph.set_yticklabels(["0","","","","","100"])
        self.memory_usage_graph.set_xticklabels([])
        self.memory_usage_canvas.draw()

        history_len = self.engine.get_config().get_stats_history_length()
        #if self.network_traffic_line == None:
            #self.network_traffic_line = self.network_traffic_graph.plot(self.engine.get_stats().network_traffic_vector(vmname))
        #else:
            #self.network_traffic_line[0].set_ydata(self.engine.get_stats().network_traffic_vector(vmname))
        self.network_traffic_graph.set_xlim(0, history_len)
        self.network_traffic_graph.set_ylim(0, 100)
        self.network_traffic_graph.set_yticklabels(["0","","","","","100"])
        self.network_traffic_graph.set_xticklabels([])
        self.network_traffic_canvas.draw()



class vmmPreferences:
    def __init__(self, engine):
        self.window = gtk.glade.XML(asset_dir + "/" + appname + ".glade", "vmm-preferences")
        self.engine = engine
        self.window.get_widget("vmm-preferences").hide()

        self.engine.get_config().on_stats_update_interval_changed(self.refresh_update_interval)
        self.engine.get_config().on_stats_history_length_changed(self.refresh_history_length)

        self.refresh_update_interval()
        self.refresh_history_length()

        self.window.signal_autoconnect({
            "on_stats_update_interval_changed": self.change_update_interval,
            "on_stats_history_length_changed": self.change_history_length,

            "on_close_clicked": self.close,
            "on_vmm_preferences_delete_event": self.close,
            })

    def close(self,ignore1=None,ignore2=None):
        self.window.get_widget("vmm-preferences").hide()
        return 1

    def show(self):
        win = self.window.get_widget("vmm-preferences")
        win.show_all()
        win.present()

    def refresh_update_interval(self, ignore1=None,ignore2=None,ignore3=None,ignore4=None):
        self.window.get_widget("stats-update-interval").set_value(self.engine.get_config().get_stats_update_interval())

    def refresh_history_length(self, ignore1=None,ignore2=None,ignore3=None,ignore4=None):
        self.window.get_widget("stats-history-length").set_value(self.engine.get_config().get_stats_history_length())

    def change_update_interval(self, src):
        self.engine.get_config().set_stats_update_interval(src.get_value_as_int())

    def change_history_length(self, src):
        self.engine.get_config().set_stats_history_length(src.get_value_as_int())


class vmmManager:
    def __init__(self, engine):
        self.window = gtk.glade.XML(asset_dir + "/" + appname + ".glade", "vmm-manager")
        self.engine = engine
        self.prepare_vmlist()

        self.engine.connect_to_signal("vm_added", self.vm_added)
        self.engine.connect_to_signal("vm_removed", self.vm_removed)
        self.engine.connect_to_signal("vm_updated", self.vm_updated)

        self.engine.get_config().on_vmlist_status_visible_changed(self.toggle_status_visible_widget)
        self.engine.get_config().on_vmlist_cpu_usage_visible_changed(self.toggle_cpu_usage_visible_widget)
        self.engine.get_config().on_vmlist_memory_usage_visible_changed(self.toggle_memory_usage_visible_widget)
        self.engine.get_config().on_vmlist_disk_usage_visible_changed(self.toggle_disk_usage_visible_widget)
        self.engine.get_config().on_vmlist_network_traffic_visible_changed(self.toggle_network_traffic_visible_widget)

        self.window.get_widget("menu_view_status").set_active(self.engine.get_config().is_vmlist_status_visible())
        self.window.get_widget("menu_view_cpu_usage").set_active(self.engine.get_config().is_vmlist_cpu_usage_visible())
        self.window.get_widget("menu_view_memory_usage").set_active(self.engine.get_config().is_vmlist_memory_usage_visible())
        self.window.get_widget("menu_view_disk_usage").set_active(self.engine.get_config().is_vmlist_disk_usage_visible())
        self.window.get_widget("menu_view_network_traffic").set_active(self.engine.get_config().is_vmlist_network_traffic_visible())

        self.window.get_widget("menu_file_new").set_sensitive(False)
        self.window.get_widget("vm-new").set_sensitive(False)
        self.window.get_widget("vm-view").set_sensitive(False)
        self.window.get_widget("vm-view").set_active(0)

        self.vmmenu = gtk.Menu()
        self.vmmenu_items = {}
        
        self.vmmenu_items["details"] = gtk.MenuItem("_Details")
        self.vmmenu_items["details"].connect("activate", self.show_vm_details)
        self.vmmenu_items["details"].show()
        self.vmmenu.add(self.vmmenu_items["details"])

        self.vmmenu_items["open"] = gtk.MenuItem("Open")
        self.vmmenu_items["open"].connect("activate", self.open_vm_console)
        self.vmmenu_items["open"].show()
        self.vmmenu.add(self.vmmenu_items["open"])

        self.vmmenu.show_all()


        self.window.signal_autoconnect({
            "on_menu_view_status_activate" : self.toggle_status_visible_conf,
            "on_menu_view_cpu_usage_activate" : self.toggle_cpu_usage_visible_conf,
            "on_menu_view_memory_usage_activate" : self.toggle_memory_usage_visible_conf,
            "on_menu_view_disk_usage_activate" : self.toggle_disk_usage_visible_conf,
            "on_menu_view_network_traffic_activate" : self.toggle_network_traffic_visible_conf,

            "on_vm_manager_delete_event": self.exit_app,
            "on_menu_file_quit_activate": self.exit_app,
            "on_vmm_close_clicked": self.exit_app,
            "on_vm_details_clicked": self.show_vm_details,
            "on_vm_open_clicked": self.open_vm_console,
            "on_menu_edit_details_activate": self.show_vm_details,

            "on_vm_list_row_activated": self.open_vm_console,

            "on_vm_list_button_press_event": self.popup_vm_menu,

            "on_menu_edit_preferences_activate": self.show_preferences,
            "on_menu_help_about_activate": self.show_about,
            })

        self.vm_selected(None)
        self.window.get_widget("vm-list").get_selection().connect("changed", self.vm_selected)


    def show(self):
        win = self.window.get_widget("vmm-manager")
        win.show_all()
        win.present()


    def exit_app(self, ignore=None,ignore2=None):
        gtk.main_quit()


    def vm_added(self, name):
        vmlist = self.window.get_widget("vm-list")
        model = vmlist.get_model()

        dup = 0
        for row in range(model.iter_n_children(None)):
            vm = model.get_value(model.iter_nth_child(None, row), 0)
            if vm == name:
                dup = 1

        if dup != 1:
            print "Add " + name
            model.append([name])


    def vm_removed(self, name):
        vmlist = self.window.get_widget("vm-list")
        model = vmlist.get_model()

        dup = 0
        for row in range(model.iter_n_children(None)):
            vm = model.get_value(model.iter_nth_child(None, row), 0)
            if vm == name:
                model.remove(model.iter_nth_child(None, row))
                print "Remove " + name
                break

    def vm_updated(self, name):
        vmlist = self.window.get_widget("vm-list")
        model = vmlist.get_model()

        for row in range(model.iter_n_children(None)):
            iter = model.iter_nth_child(None, row)
            if model.get_value(iter, 0) == name:
                model.row_changed(str(row), iter)

    def current_vm(self):
        vmlist = self.window.get_widget("vm-list")
        selection = vmlist.get_selection()
        active = selection.get_selected()
        if active[1] != None:
            return active[0].get_value(active[1], 0)
        return None

    def show_vm_details(self,ignore):
        self.engine.show_details(self.current_vm())

    def open_vm_console(self,ignore,ignore2=None,ignore3=None):
        self.engine.show_console(self.current_vm())


    def vm_selected(self, selection):
        if selection == None or selection.count_selected_rows() == 0:
            self.window.get_widget("vm-delete").set_sensitive(False)
            self.window.get_widget("vm-details").set_sensitive(False)
            self.window.get_widget("vm-open").set_sensitive(False)
            self.window.get_widget("menu_edit_delete").set_sensitive(False)
            self.window.get_widget("menu_edit_details").set_sensitive(False)
        else:
            #self.window.get_widget("vm-delete").set_sensitive(True)
            self.window.get_widget("vm-delete").set_sensitive(False)
            self.window.get_widget("vm-details").set_sensitive(True)
            self.window.get_widget("vm-open").set_sensitive(True)
            #self.window.get_widget("menu_edit_delete").set_sensitive(True)
            self.window.get_widget("menu_edit_delete").set_sensitive(False)
            self.window.get_widget("menu_edit_details").set_sensitive(True)

    def popup_vm_menu(self, widget, event):
        vm = self.current_vm()
        if vm != None:
            if event.button == 3:
                self.vmmenu.popup(None, None, None, 0, event.time)

    def show_about(self, src):
        self.engine.show_about()

    def show_preferences(self, src):
        self.engine.show_preferences()

    def prepare_vmlist(self):
        vmlist = self.window.get_widget("vm-list")

        model = gtk.ListStore(str)
        vmlist.set_model(model)

        nameCol = gtk.TreeViewColumn("Name")
        statusCol = gtk.TreeViewColumn("Status")
        cpuUsageCol = gtk.TreeViewColumn("CPU usage")
        memoryUsageCol = gtk.TreeViewColumn("Memory usage")
        diskUsageCol = gtk.TreeViewColumn("Disk usage")
        networkTrafficCol = gtk.TreeViewColumn("Network traffic")

        name_txt = gtk.CellRendererText()
        nameCol.pack_start(name_txt, True)
        nameCol.add_attribute(name_txt, 'text', 0)
        nameCol.set_sort_column_id(VMLIST_SORT_NAME)

        vmlist.append_column(nameCol)
        vmlist.append_column(statusCol)
        vmlist.append_column(cpuUsageCol)
        vmlist.append_column(memoryUsageCol)
        vmlist.append_column(diskUsageCol)
        vmlist.append_column(networkTrafficCol)

        status_txt = gtk.CellRendererText()
        status_icon = gtk.CellRendererPixbuf()
        statusCol.pack_start(status_icon, False)
        statusCol.pack_start(status_txt, False)
        statusCol.set_cell_data_func(status_txt, self.status_text, None)
        statusCol.set_cell_data_func(status_icon, self.status_icon, None)        
        statusCol.set_visible(self.engine.get_config().is_vmlist_status_visible())




        cpuUsage_txt = gtk.CellRendererText()
        cpuUsage_img = gtk.CellRendererProgress()
        cpuUsageCol.pack_start(cpuUsage_txt, False)
        cpuUsageCol.pack_start(cpuUsage_img, False)
        cpuUsageCol.set_cell_data_func(cpuUsage_txt, self.cpu_usage_text, None)
        cpuUsageCol.set_cell_data_func(cpuUsage_img, self.cpu_usage_img, None)
        cpuUsageCol.set_visible(self.engine.get_config().is_vmlist_cpu_usage_visible())
        cpuUsageCol.set_sort_column_id(VMLIST_SORT_CPU_USAGE)
        
        memoryUsage_txt = gtk.CellRendererText()
        memoryUsage_img = gtk.CellRendererProgress()
        memoryUsageCol.pack_start(memoryUsage_txt, False)
        memoryUsageCol.pack_start(memoryUsage_img, False)
        memoryUsageCol.set_cell_data_func(memoryUsage_txt, self.memory_usage_text, None)
        memoryUsageCol.set_cell_data_func(memoryUsage_img, self.memory_usage_img, None)
        memoryUsageCol.set_visible(self.engine.get_config().is_vmlist_memory_usage_visible())
        memoryUsageCol.set_sort_column_id(VMLIST_SORT_MEMORY_USAGE)
        
        diskUsage_txt = gtk.CellRendererText()
        diskUsage_img = gtk.CellRendererProgress()
        diskUsageCol.pack_start(diskUsage_txt, False)
        diskUsageCol.pack_start(diskUsage_img, False)
        diskUsageCol.set_cell_data_func(diskUsage_txt, self.disk_usage_text, None)
        diskUsageCol.set_cell_data_func(diskUsage_img, self.disk_usage_img, None)
        diskUsageCol.set_visible(self.engine.get_config().is_vmlist_disk_usage_visible())
        diskUsageCol.set_sort_column_id(VMLIST_SORT_DISK_USAGE)
        
        networkTraffic_txt = gtk.CellRendererText()
        networkTraffic_img = gtk.CellRendererProgress()
        networkTrafficCol.pack_start(networkTraffic_txt, False)
        networkTrafficCol.pack_start(networkTraffic_img, False)
        networkTrafficCol.set_cell_data_func(networkTraffic_txt, self.network_traffic_text, None)
        networkTrafficCol.set_cell_data_func(networkTraffic_img, self.network_traffic_img, None)
        networkTrafficCol.set_visible(self.engine.get_config().is_vmlist_network_traffic_visible())
        networkTrafficCol.set_sort_column_id(VMLIST_SORT_NETWORK_USAGE)

        model.set_sort_func(VMLIST_SORT_NAME, self.vmlist_name_sorter)
        model.set_sort_func(VMLIST_SORT_CPU_USAGE, self.vmlist_cpu_usage_sorter) 
        model.set_sort_func(VMLIST_SORT_MEMORY_USAGE, self.vmlist_memory_usage_sorter)
        model.set_sort_func(VMLIST_SORT_DISK_USAGE, self.vmlist_disk_usage_sorter)
        model.set_sort_func(VMLIST_SORT_NETWORK_USAGE, self.vmlist_network_usage_sorter)
        
        model.set_sort_column_id(VMLIST_SORT_NAME, gtk.SORT_ASCENDING)


    # XXX does python have a built-in sort op like perl's <=> / cmp ?
    def sort_op(self, a, b):
        if a > b:
            return 1
        elif a < b:
            return -1
        return 0

    def vmlist_name_sorter(self, model, iter1, iter2):
        print "Sort "+ model.get_value(iter1, 0) + " <=> " + model.get_value(iter2, 0)
        return self.sort_op(model.get_value(iter1, 0), model.get_value(iter2, 0))

    def vmlist_cpu_usage_sorter(self, model, iter1, iter2):
        return self.sort_op(self.engine.get_stats().cpu_time(model.get_value(iter1, 0)), self.engine.get_stats().cpu_time(model.get_value(iter2, 0)))

    def vmlist_memory_usage_sorter(self, model, iter1, iter2):
        return self.sort_op(self.engine.get_stats().current_memory(model.get_value(iter1, 0)), self.engine.get_stats().current_memory(model.get_value(iter2, 0)))

    def vmlist_disk_usage_sorter(self, model, iter1, iter2):
        return self.sort_op(self.engine.get_stats().disk_usage(model.get_value(iter1, 0)), self.engine.get_stats().disk_usage(model.get_value(iter2, 0)))

    def vmlist_network_usage_sorter(self, model, iter1, iter2):
        return self.sort_op(self.engine.get_stats().network_traffic(model.get_value(iter1, 0)), self.engine.get_stats().network_traffic(model.get_value(iter2, 0)))

    def toggle_status_visible_conf(self, menu):
        self.engine.get_config().set_vmlist_status_visible(menu.get_active())

    def toggle_status_visible_widget(self, ignore1, ignore2, ignore3, ignore4):
        menu = self.window.get_widget("menu_view_status")
        vmlist = self.window.get_widget("vm-list")
        col = vmlist.get_column(1)
        col.set_visible(self.engine.get_config().is_vmlist_status_visible())

    def toggle_cpu_usage_visible_conf(self, menu):
        self.engine.get_config().set_vmlist_cpu_usage_visible(menu.get_active())

    def toggle_cpu_usage_visible_widget(self, ignore1, ignore2, ignore3, ignore4):
        menu = self.window.get_widget("menu_view_cpu_usage")
        vmlist = self.window.get_widget("vm-list")
        col = vmlist.get_column(2)
        col.set_visible(self.engine.get_config().is_vmlist_cpu_usage_visible())

    def toggle_memory_usage_visible_conf(self, menu):
        self.engine.get_config().set_vmlist_memory_usage_visible(menu.get_active())

    def toggle_memory_usage_visible_widget(self, ignore1, ignore2, ignore3, ignore4):
        menu = self.window.get_widget("menu_view_memory_usage")
        vmlist = self.window.get_widget("vm-list")
        col = vmlist.get_column(3)
        col.set_visible(self.engine.get_config().is_vmlist_memory_usage_visible())

    def toggle_disk_usage_visible_conf(self, menu):
        self.engine.get_config().set_vmlist_disk_usage_visible(menu.get_active())

    def toggle_disk_usage_visible_widget(self, ignore1, ignore2, ignore3, ignore4):
        menu = self.window.get_widget("menu_view_disk_usage")
        vmlist = self.window.get_widget("vm-list")
        col = vmlist.get_column(4)
        col.set_visible(self.engine.get_config().is_vmlist_disk_usage_visible())

    def toggle_network_traffic_visible_conf(self, menu):
        self.engine.get_config().set_vmlist_network_traffic_visible(menu.get_active())

    def toggle_network_traffic_visible_widget(self, ignore1, ignore2, ignore3, ignore4):
        menu = self.window.get_widget("menu_view_network_traffic")
        vmlist = self.window.get_widget("vm-list")
        col = vmlist.get_column(5)
        col.set_visible(self.engine.get_config().is_vmlist_network_traffic_visible())


    def status_text(self, column, cell, model, iter, data):
        name = model.get_value(iter, 0)
        cell.set_property('text', self.engine.get_stats().run_status(name))

    def status_icon(self, column, cell, model, iter, data):
        name = model.get_value(iter, 0)
        cell.set_property('pixbuf', self.engine.get_stats().run_status_icon(name))

    def cpu_usage_text(self,  column, cell, model, iter, data):
        name = model.get_value(iter, 0)
        cell.set_property('text', "%2.2f %%" % self.engine.get_stats().cpu_time_percentage(name))

    def cpu_usage_img(self,  column, cell, model, iter, data):
        name = model.get_value(iter, 0)
        cell.set_property('text', '')
        cell.set_property('value', self.engine.get_stats().cpu_time_percentage(name))

    def memory_usage_text(self,  column, cell, model, iter, data):
        name = model.get_value(iter, 0)
        current = self.engine.get_stats().current_memory(name)
        currentPercent = self.engine.get_stats().current_memory_percentage(name)
        cell.set_property('text', "%s (%2.2f%%)" % (self.pretty_mem(current) , currentPercent))

    def memory_usage_img(self,  column, cell, model, iter, data):
        name = model.get_value(iter, 0)
        currentPercent = self.engine.get_stats().current_memory_percentage(name)
        cell.set_property('text', '')
        cell.set_property('value', currentPercent)

    def disk_usage_text(self,  column, cell, model, iter, data):
        name = model.get_value(iter, 0)
        current = self.engine.get_stats().disk_usage(name)
        currentPercent = self.engine.get_stats().disk_usage_percentage(name)
        cell.set_property('text', "%s (%2.2f%%)" % (self.pretty_mem(current) , currentPercent))

    def disk_usage_img(self,  column, cell, model, iter, data):
        name = model.get_value(iter, 0)
        currentPercent = self.engine.get_stats().disk_usage_percentage(name)
        cell.set_property('text', '')
        cell.set_property('value', currentPercent)

    def network_traffic_text(self,  column, cell, model, iter, data):
        name = model.get_value(iter, 0)
        current = self.engine.get_stats().network_traffic(name)
        currentPercent = self.engine.get_stats().network_traffic_percentage(name)
        cell.set_property('text', "%s (%2.2f%%)" % (self.pretty_mem(current) , currentPercent))

    def network_traffic_img(self,  column, cell, model, iter, data):
        name = model.get_value(iter, 0)
        currentPercent = self.engine.get_stats().network_traffic_percentage(name)
        cell.set_property('text', '')
        cell.set_property('value', currentPercent)

    # XXX or should we just always display MB ?
    def pretty_mem(self, mem):
        if mem > (1024*1024):
            return "%2.2f GB" % (mem/(1024.0*1024.0))
        else:
            return "%2.2f MB" % (mem/1024.0)


class vmmConfig:
    def __init__(self):
        self.conf = gconf.client_get_default()
        self.conf.add_dir (gconf_dir,
                           gconf.CLIENT_PRELOAD_NONE)

    def is_vmlist_status_visible(self):
        return self.conf.get_bool(gconf_dir + "/vmlist-fields/status")

    def is_vmlist_cpu_usage_visible(self):
        return self.conf.get_bool(gconf_dir + "/vmlist-fields/cpu_usage")

    def is_vmlist_memory_usage_visible(self):
        return self.conf.get_bool(gconf_dir + "/vmlist-fields/memory_usage")

    def is_vmlist_disk_usage_visible(self):
        return self.conf.get_bool(gconf_dir + "/vmlist-fields/disk_usage")

    def is_vmlist_network_traffic_visible(self):
        return self.conf.get_bool(gconf_dir + "/vmlist-fields/network_traffic")



    def set_vmlist_status_visible(self, state):
        self.conf.set_bool(gconf_dir + "/vmlist-fields/status", state)
        
    def set_vmlist_cpu_usage_visible(self, state):
        self.conf.set_bool(gconf_dir + "/vmlist-fields/cpu_usage", state)
        
    def set_vmlist_memory_usage_visible(self, state):
        self.conf.set_bool(gconf_dir + "/vmlist-fields/memory_usage", state)
        
    def set_vmlist_disk_usage_visible(self, state):
        self.conf.set_bool(gconf_dir + "/vmlist-fields/disk_usage", state)
        
    def set_vmlist_network_traffic_visible(self, state):
        self.conf.set_bool(gconf_dir + "/vmlist-fields/network_traffic", state)



    def on_vmlist_status_visible_changed(self, callback):
        self.conf.notify_add(gconf_dir + "/vmlist-fields/status", callback)

    def on_vmlist_cpu_usage_visible_changed(self, callback):
        self.conf.notify_add(gconf_dir + "/vmlist-fields/cpu_usage", callback)

    def on_vmlist_memory_usage_visible_changed(self, callback):
        self.conf.notify_add(gconf_dir + "/vmlist-fields/memory_usage", callback)

    def on_vmlist_disk_usage_visible_changed(self, callback):
        self.conf.notify_add(gconf_dir + "/vmlist-fields/disk_usage", callback)

    def on_vmlist_network_traffic_visible_changed(self, callback):
        self.conf.notify_add(gconf_dir + "/vmlist-fields/network_traffic", callback)



    def get_stats_update_interval(self):
        interval = self.conf.get_int(gconf_dir + "/stats/update-interval")
        if interval < 1:
            return 1
        return interval

    def get_stats_history_length(self):
        history = self.conf.get_int(gconf_dir + "/stats/history-length")
        if history < 10:
            return 10
        return history


    def set_stats_update_interval(self, interval):
        self.conf.set_int(gconf_dir + "/stats/update-interval", interval)

    def set_stats_history_length(self, length):
        self.conf.set_int(gconf_dir + "/stats/history-length", length)


    def on_stats_update_interval_changed(self, callback):
        self.conf.notify_add(gconf_dir + "/stats/update-interval", callback)

    def on_stats_history_length_changed(self, callback):
        self.conf.notify_add(gconf_dir + "/stats/history-length", callback)


class vmmStats:
    def __init__(self, engine, hostinfo):
        self.engine = engine
        self.hostinfo = hostinfo
        self.record = {}

        self.status_icons = {
            "blocked": gtk.gdk.pixbuf_new_from_file(asset_dir + "/pixmaps/state_blocked.png"),
            "crashed": gtk.gdk.pixbuf_new_from_file(asset_dir + "/pixmaps/state_crashed.png"),
            "paused": gtk.gdk.pixbuf_new_from_file(asset_dir + "/pixmaps/state_paused.png"),
            "running": gtk.gdk.pixbuf_new_from_file(asset_dir + "/pixmaps/state_running.png"),
            "shutdown": gtk.gdk.pixbuf_new_from_file(asset_dir + "/pixmaps/state_shutdown.png"),
            "shutoff": gtk.gdk.pixbuf_new_from_file(asset_dir + "/pixmaps/state_shutoff.png"),
            "idle": gtk.gdk.pixbuf_new_from_file(asset_dir + "/pixmaps/state_idle.png"),
            }

        self.engine.connect_to_signal("vm_added", self.vm_added)


    def vm_added(self, vmname):
        self.record[vmname] = []

    def vm_removed(self, vmname):
        del self.record[vmname]

    def update(self, vmname, vm):
        now = time()

        info = vm.info()

        expected = self.engine.get_config().get_stats_history_length()
        current = len(self.record[vmname])
        if current > expected:
            del self.record[vmname][expected:current]
            print "Lengh " + str(len(self.record[vmname]))
            
        prevCpuTime = 0
        prevTimestamp = 0
        if len(self.record[vmname]) > 0:
            prevTimestamp = self.record[vmname][0]["timestamp"]
            prevCpuTime = self.record[vmname][0]["cpuTimeAbs"]

        pcentCpuTime = (info[4]-prevCpuTime) * 100 / ((now - prevTimestamp)*1000*1000*1000)
        pcentCpuTime = pcentCpuTime / self.host_active_processor_count()
        
        pcentCurrMem = info[2] * 100 / self.host_memory_size()
        pcentMaxMem = info[1] * 100 / self.host_memory_size()
        
        newStats = { "timestamp": now,
                     "status": info[0],
                     "cpuTime": (info[4]-prevCpuTime),
                     "cpuTimeAbs": info[4],
                     "cpuTimePercent": pcentCpuTime,
                     "currMem": info[2],
                     "currMemPercent": pcentCurrMem,
                     "maxMem": info[1],
                     "maxMemPercent": pcentMaxMem,
                     }

        self.record[vmname].insert(0, newStats)
        

    def host_memory_size(self):
        return self.hostinfo[1]*1024

    def host_active_processor_count(self):
        return self.hostinfo[2]

    def host_maximum_processor_count(self):
        return self.hostinfo[4] * self.hostinfo[5] * self.hostinfo[6] * self.hostinfo[7]

    def current_memory(self, vmname):
        if len(self.record[vmname]) == 0:
            return 0
        return self.record[vmname][0]["currMem"]
    
    def current_memory_percentage(self, vmname):
        if len(self.record[vmname]) == 0:
            return 0
        return self.record[vmname][0]["currMemPercent"]
    
    def maximum_memory(self, vmname):
        if len(self.record[vmname]) == 0:
            return 0
        return self.record[vmname][0]["maxMem"]

    def maximum_memory_percentage(self, vmname):
        if len(self.record[vmname]) == 0:
            return 0
        return self.record[vmname][0]["maxMemPercent"]

    def cpu_time(self, vmname):
        if len(self.record[vmname]) == 0:
            return 0
        return self.record[vmname][0]["cpuTime"]
    
    def cpu_time_percentage(self, vmname):
        if len(self.record[vmname]) == 0:
            return 0
        return self.record[vmname][0]["cpuTimePercent"]

    def network_traffic(self, vmname):
        return 1

    def network_traffic_percentage(self, vmname):
        return 1

    def disk_usage(self, vmname):
        return 1

    def disk_usage_percentage(self, vmname):
        return 1

    def cpu_time_vector(self, vmname):
        vector = []
        stats = self.record[vmname]
        for i in range(self.engine.get_config().get_stats_history_length()+1):
            if i < len(stats):
                vector.append(stats[i]["cpuTimePercent"])
            else:
                vector.append(0)
        return vector
    
    def current_memory_vector(self, vmname):
        vector = []
        stats = self.record[vmname]
        for i in range(self.engine.get_config().get_stats_history_length()+1):
            if i < len(stats):
                vector.append(stats[i]["currMemPercent"])
            else:
                vector.append(0)
        return vector
    
    def network_traffic_vector(self, vmname):
        vector = []
        stats = self.record[vmname]
        for i in range(self.engine.get_config().get_stats_history_length()+1):
            vector.append(1)
        return vector
    
    def disk_usage_vector(self, vmname):
        vector = []
        stats = self.record[vmname]
        for i in range(self.engine.get_config().get_stats_history_length()+1):
            vector.append(1)
        return vector
    
    
    def run_status(self, vmname):
        if len(self.record[vmname]) == 0:
            return "Shutoff"
        status = self.record[vmname][0]["status"]
        if status == libvirt.VIR_DOMAIN_NOSTATE:
            return "Idle"
        elif status == libvirt.VIR_DOMAIN_RUNNING:
            return "Running"
        elif status == libvirt.VIR_DOMAIN_BLOCKED:
            return "Blocked"
        elif status == libvirt.VIR_DOMAIN_PAUSED:
            return "Paused"
        elif status == libvirt.VIR_DOMAIN_SHUTDOWN:
            return "Shutdown"
        elif status == libvirt.VIR_DOMAIN_SHUTOFF:
            return "Shutoff"
        elif status == libvirt.VIR_DOMAIN_CRASHED:
            return "Crashed"
        else:
            raise "Unknown status code"

    def run_status_icon(self, name):
        status = self.run_status(name)
        return self.status_icons[status.lower()]

class vmmEngine:
    def __init__(self):
        self.config = None
        self.vmm = libvirt.openReadOnly(None)
        #self.vmm = libvirt.open(None)
        self.windowManager = None
        self.windowPreferences = None
        self.windowAbout = None
        self.windowDetails = {}
        self.windowConsole = {}
        self.vms = {}
        
        self.timer = None
        self.last_timeout = 0

        self.callbacks = { "vm_added": [], "vm_removed": [], "vm_updated": [] }

        self.config = vmmConfig()
        self.stats = vmmStats(self, self.vmm.getInfo())
        self.config.on_stats_update_interval_changed(self.reschedule_timer)

        self.schedule_timer()
        self.windowManager = vmmManager(self)
        self.tick()

    def reschedule_timer(self, ignore1,ignore2,ignore3,ignore4):
        self.schedule_timer()

    def schedule_timer(self):
        interval = self.get_config().get_stats_update_interval() * 1000
        now = time() * 1000
        print "Scheule at " + str(interval)
        if self.timer != None:
            gobject.source_remove(self.timer)
            self.timer = None

        self.timer = gobject.timeout_add(interval, self.tick)

    def change_timer_interval(self,ignore1,ignore2,ignore3,ignore4):
        print "Removing timer"
        gobject.source_remove(self.timer)
        self.refresh_stats()
        self.schedule_timer()


    def connect_to_signal(self, name, callback):
        if not(self.callbacks.has_key(name)):
            raise "unknown signal " + name + "requested"

        self.callbacks[name].append(callback)

    def disconnect_from_signal(self, name, callback):
        for i in len(self.callbacks[name]):
            if self.callbacks[i] == callback:
                del self.callbacks[i:i]
                

    def notify_vm_added(self, name):
        for cb in self.callbacks["vm_added"]:
            cb(name)

    def notify_vm_removed(self, name):
        for cb in self.callbacks["vm_removed"]:
            cb(name)

    def notify_vm_updated(self, name):
        for cb in self.callbacks["vm_updated"]:
            cb(name)

    def get_config(self):
        return self.config

    def get_stats(self):
        return self.stats

    def show_about(self):
        if self.windowAbout == None:
            self.windowAbout = vmmAbout()
        self.windowAbout.show()

    def show_preferences(self):
        if self.windowPreferences == None:
            self.windowPreferences = vmmPreferences(self)
        self.windowPreferences.show()

    def show_manager(self):    
        self.windowManager.show()

    def show_details(self, vmname):
        if not(self.windowDetails.has_key(vmname)):
            self.windowDetails[vmname] = vmmDetails(self, vmname)

        self.windowDetails[vmname].show()

    def show_console(self, vmname):
        if not(self.windowConsole.has_key(vmname)):
            self.windowConsole[vmname] = vmmConsole(self, vmname)

        self.windowConsole[vmname].show()


    def tick(self):
        print "Tick"
        doms = self.vmm.listDomainsID()
        newVms = {}
        if doms != None:
            for id in doms:
                vm = self.vmm.lookupByID(id)
                newVms[vm.name()] = vm

        for name in self.vms.keys():
            if not(newVms.has_key(name)):
                del self.vms[name]
                self.notify_vm_removed(name)

        for name in newVms.keys():
            if not(self.vms.has_key(name)):
                self.vms[name] = newVms[name]
                self.notify_vm_added(name)

        for name in self.vms.keys():
            self.stats.update(name, self.vms[name])
            self.notify_vm_updated(name)

        return 1
        

        
# Run me!
def main():
    engine = vmmEngine()
    engine.show_manager()
    gtk.main()

if __name__ == "__main__":
    main()
