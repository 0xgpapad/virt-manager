# -*- python -*-
#
# Copyright (C) 2006 Red Hat, Inc.
# Copyright (C) 2006 Daniel P. Berrange <berrange@redhat.com>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#

from os import getcwd
import os.path
import sys

import locale
import gettext
import logging

gettext_app = "virt-manager"
gettext_dir = "::GETTEXTDIR::"

locale.setlocale(locale.LC_ALL, '')
gettext.install(gettext_app, gettext_dir)

# set up logging
vm_dir = os.path.expanduser("~/.virt-manager")
if not os.access(vm_dir,os.W_OK):
    try:
        os.mkdir(vm_dir)
    except IOError, e:
        raise RuntimeError, "Could not create %d directory: " % vm_dir, e

# XXX should we get logging level from gconf, or command line args ?
logging.basicConfig(level=logging.DEBUG,
                    format="%(asctime)s %(levelname)-8s %(message)s",
                    datefmt="%a, %d %b %Y %H:%M:%S",
                    filename="%s/virt-manager.log" % vm_dir,
                    filemode='w')

# Urgh, pygtk merely logs a warning when failing to open
# the X11 display connection, and lets everything carry
# on as if all were fine. Ultimately bad stuff happens,
# so lets catch it here & get the hell out...
import warnings
warnings.filterwarnings('error', module='gtk')
try:
    import gtk
except Warning, e:
    # ...the risk is we catch too much though
    # Damned if we do, damned if we dont :-)(
    print _("Unable to initialize GTK: ") + str(e)
    sys.exit(1)
warnings.resetwarnings()

import gtk
gtk.gdk.threads_init()

import dbus
import dbus.glib
dbus.glib.threads_init()
import dbus.service

from optparse import OptionParser

appname = "::PACKAGE::"
appversion = "::VERSION::"
gconf_dir = "/apps/" + appname
asset_dir = "::ASSETDIR::"
glade_dir = asset_dir
icon_dir = asset_dir + "/pixmaps"
pylib_dir = "::PYLIBDIR::"
pyarchlib_dir = "::PYARCHLIBDIR::"

# Hack for dev purposes
if os.path.exists(os.getcwd() + "/src/" + appname + ".glade"):
    glade_dir = os.getcwd() + "/src"
if os.path.exists(os.getcwd() + "/pixmaps/icon_run.png"):
    icon_dir = os.getcwd() + "/pixmaps"

if os.path.exists(os.getcwd() + "/src/virt-manager.py"):
    sys.path.insert(0, os.getcwd() + "/src/graphWidgets/.libs")
elif os.path.exists(os.getcwd() + "/build/src/virt-manager.py"):
    sys.path.insert(0, os.getcwd() + "/src")
    sys.path.insert(0, os.getcwd() + "/build/src/graphWidgets/.libs")
else:
    sys.path.insert(0, pylib_dir)
    sys.path.insert(0, pyarchlib_dir)

from virtManager.config import vmmConfig
from virtManager.engine import vmmEngine
from virtManager.remote import vmmRemote

gtk.window_set_default_icon_from_file(icon_dir + "/" + appname + "-icon.svg")

# Run me!
def main():
    optParser = OptionParser()
    optParser.add_option("-c", "--connect", dest="uri", help="Connect to hypervisor at URI", metavar="URI")
    optParser.add_option("--no-dbus", action="store_true", dest="nodbus", help="Disable DBus service for controlling UI")

    (options, args) = optParser.parse_args()

    config = vmmConfig(appname, appversion, gconf_dir, glade_dir, icon_dir)
    engine = vmmEngine(config)
    if options.nodbus:
        if options.uri != None:
            engine.show_manager(options.uri)
        else:
            engine.show_connect()
    else:
        bus = None
        try:
            if os.getenv("DBUS_STARTER_ADDRESS") == None and os.getenv("DBUS_SESSION_BUS_ADDRESS") == None:
                raise RuntimeError, "DBus session/starter bus address not defined"
            bus = dbus.SessionBus()

            dbusProxy = bus.get_object("org.freedesktop.DBus", "/org/freedesktop/DBus")
            dbusObj = dbus.Interface(dbusProxy, "org.freedesktop.DBus")

            # If we're already running, then just talk to existing process
            if os.getenv("DBUS_STARTER_ADDRESS"):
                name = dbus.service.BusName("com.redhat.virt.manager", bus=bus)
                remote = vmmRemote(engine, name)
            else:
                managerProxy = bus.get_object("com.redhat.virt.manager", "/com/redhat/virt/manager")
                managerObj = dbus.Interface(managerProxy, "com.redhat.virt.manager")

                if options.uri != None:
                    managerObj.show_host_summary(options.uri)
                else:
                    managerObj.show_connect()
                # yes, we exit completely now - remote service is in charge
                return
        except:
            logging.warning("Could not connection to session bus, disabling DBus service " + \
                            str(sys.exc_info()[0]) + " " + str(sys.exc_info()[1]))
            if options.uri != None:
                engine.show_manager(options.uri)
            else:
                engine.show_connect()
    gtk.main()

if __name__ == "__main__":
    main()
